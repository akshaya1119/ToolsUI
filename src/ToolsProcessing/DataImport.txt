import React, { useEffect, useState } from 'react';
import {
  Row,
  Col,
  Card,
  Select,
  Upload,
  Button,
  Typography,
  Radio,
  Checkbox,
  InputNumber,
  Space,
  message,
  Table,
} from 'antd';
import { UploadOutlined, DownloadOutlined } from '@ant-design/icons';
import * as XLSX from 'xlsx';
import ProcessingPipeline from './ProcessingPipeline'; // Your pipeline component
import axios from 'axios';
import ExcelImportService from '../services/FileUpload';



const { Title, Text } = Typography;
const { Option } = Select;
const url = import.meta.env.VITE_API_BASE_URL;
const url1 = import.meta.env.VITE_API_URL;

const DataImport = () => {
  const [project, setProject] = useState(null);
  // Processing options moved to Duplicate Tool
  // const [strategy, setStrategy] = useState('consolidate');
  // const [enhance, setEnhance] = useState(false);
  // const [roundUp, setRoundUp] = useState(true);
  // const [percent, setPercent] = useState(2.5);
  const [processingStarted, setProcessingStarted] = useState(false);
  const [projects, setProjects] = useState([]);
  const [fileHeaders, setFileHeaders] = useState([]);
  const [expectedFields, setExpectedFields] = useState([]);
  const [fieldMappings, setFieldMappings] = useState({});
  const [excelData, setExcelData] = useState([]);

  const [viewConflicts, setViewConflicts] = useState(false);
  const [conflicts, setConflicts] = useState(null);
  const [conflictSelections, setConflictSelections] = useState({});
  const token = localStorage.getItem('token');
  const [myData, setMyData] = useState([]);//data to send in payload

  const predefinedFields = [
  {
    key: 'CatchNo',
    label: 'Catch Number',
    required: true,
    variations: ['CatchNo', 'catch no', 'catchno']
  },
  {
    key: 'SubjectName',
    label: 'Subject Name',
    required: true,
    variations: ['SubjectName', 'subject', 'subject name']
  },
  {
    key: 'CenterCode',
    label: 'Center Code',
    required: true,
    variations: ['CenterCode', 'center code', 'centre code']
  },
  {
    key: 'CourseName',
    label: 'Course Name',
    required: true,
    variations: ['CourseName', 'course', 'course name']
  },
  {
    key: 'ExamDate',
    label: 'Exam Date',
    required: true,
    variations: ['ExamDate', 'exam date', 'date']
  },
  {
    key: 'ExamTime',
    label: 'Exam Time',
    required: true,
    variations: ['ExamTime', 'exam time', 'time']
  },
{
    key: 'PaperName',
    label: 'Paper Name',
    required: true,
    fromColumn: 'NRDatas', // indicates to extract this from JSON
    path: 'PaperName'      // JSON path
  },
  {
    key: 'PaperCode',
    label: 'Paper Code',
    required: true,
    fromColumn: 'NRDatas',
    path: 'PaperCode'
  },
  {
    key: 'Quantity',
    label: 'Quantity',
    required: false,
    variations: ['Quantity', 'qty', 'number', 'count']
  }
];


  useEffect(() => {
    axios.get(`${url}/Project`, {
      headers: { Authorization: `Bearer ${token}` }
    })
      .then(res => setProjects(res.data))
      .catch(err => console.error("Failed to fetch projects", err));
  }, []);

  useEffect(() => {
    if (!project) return;

    axios.get(`/Fields`, {
      headers: { Authorization: `Bearer ${token}` }
    })
      .then(res => setExpectedFields(res.data))
      .catch(err => console.error("Failed to fetch fields", err));
  }, [project]);

  const isAnyFieldMapped = () => {
    return expectedFields.some(field => fieldMappings[field.fieldId]);
  };

  const readExcel = (file) => {
    const reader = new FileReader();

    reader.onload = (e) => {
      const data = new Uint8Array(e.target.result);
      const workbook = XLSX.read(data, { type: 'array' });
      const worksheet = workbook.Sheets[workbook.SheetNames[0]];
      const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
      const headers = jsonData[0];
      const rows = jsonData.slice(1);
      setFileHeaders(headers);
      setExcelData(rows);
    };

    reader.readAsArrayBuffer(file);
  };

  const handleStartProcessing = () => {
    setProcessingStarted(true);
  };
  
   const handleDataChange = (newData) => {
    setMyData(newData);
    console.log('Received Data:', newData);
  };
  // Processing Options removed from Data Import page

  const resetForm = () => {
    setProject(null);
    setFileHeaders([]);
    setFieldMappings({});
    setExcelData([]);
    setProcessingStarted(false);
    setExpectedFields([]);
    setViewConflicts(false);
    setConflicts(null);
  };

  const handleUpload = () => {
    const mappedData = getMappedData();
    const payload = {
      projectId: project,
      data: mappedData
    };

    API.post(`/NRDatas`, payload, {
      headers: { Authorization: `Bearer ${token}` }
    })
      .then(res => {
        console.log('Validation result:', res.data);
        message.success("Validation successful");
         setTimeout(() => {
      resetForm();
    }, 1500);
      })
      .catch(err => {
        console.error("Validation failed", err);
        message.error("Validation failed");
        resetForm();
      });
  };

  const getMappedData = () => {
    if (!excelData.length || !fileHeaders.length) return [];

    return excelData.map((row) => {
      const mappedRow = {};
      expectedFields.forEach((field) => {
        const column = fieldMappings[field.fieldId];
        if (column) {
          const colIndex = fileHeaders.indexOf(column);
          mappedRow[field.name] = row[colIndex] ?? null;
        }
      });
      return mappedRow;
    });
  };

  const fetchConflictReport = async () => {
    if (!project) {
      message.warning("Please select a project first.");
      return;
    }

    try {
      const res = await axios.get(`/NRDatas/ErrorReport?ProjectId=${project}`, {
        headers: { Authorization: `Bearer ${token}` }
      });
      setConflicts(res.data);
      setViewConflicts(true);
    } catch (err) {
      console.error("Failed to fetch conflict report", err);
      message.error("Failed to load conflicts");
    }
  };

  // Processing Options removed - now located on Duplicate Tool page
  const renderProcessingOptions = () => null;

  const handleSelectionChange = (catchNo, value) => {
    setConflictSelections(prev => ({
      ...prev,
      [catchNo]: value
    }));
  };

  const handleSave = async (record) => {
    const selectedValue = conflictSelections[record.catchNo];

    if (!selectedValue) {
      message.warning('Please select a value before saving.');
      return;
    }

    const payload = {
      catchNo: record.catchNo,
      uniqueField: record.uniqueField,
      selectedValue: selectedValue
    };

    try {
      await API.put(`/NRDatas?ProjectId=${project}`, payload, {
        headers: { Authorization: `Bearer ${token}` }
      });
      message.success(`Resolved conflict for ${record.catchNo}`);
      fetchConflictReport();
    } catch (error) {
      console.error('Error saving resolution:', error);
      message.error('Failed to resolve conflict');
    }
  };

  

  const renderConflicts = () => {
    if (!conflicts) return null;

    const columns = [
      {
        title: 'Catch No.',
        dataIndex: 'catchNo',
        key: 'catchNo',
      },
      {
        title: 'Conflicting Field',
        dataIndex: 'uniqueField',
        key: 'uniqueField',
      },
      {
        title: 'Value 1',
        dataIndex: 'value1',
        key: 'value1',
      },
      {
        title: 'Value 2',
        dataIndex: 'value2',
        key: 'value2',
      },
      {
        title: 'ResolveConflicts',
        key: 'resolveconflicts',
        render: (_, record) => {
          const selectedValue = conflictSelections[record.catchNo];
          return(
          <Space direction="vertical" style={{ width: '100%' }}>
            <Select
              style={{ width: '100%' }}
              placeholder="Select value to keep"
              value={conflictSelections[record.catchNo]}
              onChange={(value) => handleSelectionChange(record.catchNo, value)}
            >
              <Option value={record.value1}>{record.value1}</Option>
              <Option value={record.value2}>{record.value2}</Option>
            </Select>
            <Button type="primary" onClick={() => handleSave(record)} disabled={!selectedValue}>
              Save
            </Button>
          </Space>
          )
        }
      },
    ];

    const dataSource = (conflicts?.errors ?? []).map((error, index) => ({
      key: index,
      catchNo: error.catchNo,
      uniqueField: error.uniqueField,
      value1: error.conflictingValues[0],
      value2: error.conflictingValues[1],
    }));

    return (
      <Card title="Conflict Report" style={{ marginTop: 24 }}>
        {!conflicts || !Array.isArray(conflicts.errors) ? (
          <Text type="warning">⚠️ No conflicts found</Text>
        ) : conflicts.duplicatesFound ? (
          <Table
            columns={columns}
            dataSource={dataSource}
            pagination={false}
          />
        ) : (
          <Text type="success">✅ No duplicates found</Text>
        )}
      </Card>

    );
  };

  return (
    <div style={{ padding: 24 }}>
      <Row gutter={[24, 24]}>
        {/* Left Section */}
        <Col xs={24} lg={18}>
          {/* Data Import Card */}
<Card title="Data Import" bordered={false}>
  <Space direction="vertical" style={{ width: '100%' }} size="large">
    {/* Row with Select Project and Upload Config side by side */}
    <Row gutter={16}>
      {/* Select Project */}
      <Col span={12}>
        <div>
          <Text strong>Select Project</Text>
          <Select
            style={{ width: '100%', marginTop: 4 }}
            placeholder="Choose a project..."
            onChange={setProject}
          >
            <Option value="">Choose a Project...</Option>
            {projects.map(project => (
              <Option key={project.projectId} value={project.projectId}>{project.name}</Option>
            ))}
          </Select>
        </div>
      </Col>

      {/* Upload Config */}
      {/* <Col span={12}>
        <Upload.Dragger
          name="file"
          accept=".xls,.xlsx,.csv"
          beforeUpload={(file) => {
            readExcel(file);  // Function to read the file
            return false;
          }}
          maxCount={1}
        >
          <p style={{ fontSize: 24 }}>📤</p>
          <p>Upload Excel or CSV file</p>
          <Button icon={<UploadOutlined />}>Choose File</Button>
          <p style={{ color: '#999' }}>
            Supported formats: .xlsx, .xls, .csv (Max: 10MB)
          </p>
        </Upload.Dragger>
      </Col> */}
    </Row>

    {/* Display the number of records found in the uploaded Excel file */}
    {/* {excelData.length > 0 && (
      <Text type="secondary" style={{ marginTop: 8 }}>
        {`Records Found: ${excelData.length}`}
      </Text>
    )} */}

    {/* Display Upload and Validate button when fields are mapped */}
   
  </Space>
</Card>

         <div className="min-h-screen bg-gray-100 p-4">
      <div className="">
        <div className="bg-white rounded-lg shadow-lg overflow-hidden">
          <ExcelImportService
            predefinedFields={predefinedFields}
            onDataChange={handleDataChange}
            debugMode={false}
            exportJsonEnabled={true}
          />
        </div>
      </div> {isAnyFieldMapped() && ( <Button type="primary" block onClick={handleUpload}> Upload and Validate </Button> )}
    </div>
   


          <div style={{ marginTop: 24 }}>
            {processingStarted ? (
              <ProcessingPipeline />
            ) : viewConflicts ? (
              renderConflicts()
            ) : (
              renderProcessingOptions()
            )}
          </div>
        </Col>

        {/* Right Section */}
        <Col xs={24} lg={6}>
          <Card title="Quick Actions" bordered={false}>
            <Space direction="vertical" style={{ width: '100%' }}>
              <Button block onClick={fetchConflictReport}>� Load conflict report</Button>
              {viewConflicts && (
                <Button block onClick={() => setViewConflicts(false)}>⬅️ Back</Button>
              )}
            </Space>
          </Card>
        </Col>
      </Row>
    </div>
  );
};

export default DataImport;
